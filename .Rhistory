stop("无法确定文件编码，请检查文件格式")
}
message(paste("检测到文件编码为:", encoding))
# 3.检查编码是否支持转换
if (!encoding %in% iconvlist()) {
stop(paste("不支持的编码格式:", encoding))
}
# 4.读取文件二进制内容
tryCatch({
binary_content <- readBin(file_path, "raw", file.info(file_path)$size)
message("成功读取文件二进制内容")
print(paste("读取到", length(binary_content), "字节数据"))
}, error = function(e) {
stop(paste("读取文件二进制内容时出错:", e$message))
})
# 5. 使用iconv将二进制内容转换为UTF-8编码文本内容
raw_text <- iconv(list(binary_content), from = encoding, to = "UTF-8")
# 6. 合并为单个字符串
full_text <- paste(raw_text, collapse = " ")
# 7. 使用正则表达式提取每条记录，每条记录以"CITIBANK"开始
records <- unlist(strsplit(full_text, '"CITIBANK'))
# 8. 移除第一个元素（如果它是空的）
if (records[1] == "") {
records <- records[-1]
}
# 9. 为每条记录重新添加"CITIBANK"前缀
records <- paste0('"CITIBANK', records)
# 10. 预分配结果列表
parsed_records <- list()
# 11. 遍历每条记录
for (i in seq_along(records)) {
# 提取双引号之间的内容
fields <- gregexpr('"[^"]*"', records[i])
field_contents <- regmatches(records[i], fields)[[1]]
# 移除双引号
field_contents <- gsub('"', '', field_contents)
# 添加到结果列表
parsed_records[[i]] <- field_contents
}
# 12. 确定最大字段数
max_fields <- max(sapply(parsed_records, length))
# 13. 创建数据框
result_df <- data.frame(matrix(NA, nrow = length(parsed_records), ncol = max_fields))
# 14. 填充数据框
for (i in seq_along(parsed_records)) {
result_df[i, 1:length(parsed_records[[i]])] <- parsed_records[[i]]
}
# 15. 设置列名
colnames(result_df) <- paste0("Field", 1:max_fields)
# 16. 读取字段映射文件并应用列名
field_mappings <- read.table("app/r_scripts/r_processor/fields_mapping.txt", sep = "\n",
stringsAsFactors = FALSE, strip.white = TRUE,
col.names = c("original", "mapped"))
# 创建一个映射表，记录每个目标列名对应的原始列名
mapped_columns <- list()
for (i in 1:nrow(field_mappings)) {
field_name <- field_mappings$original[i]
mapped_name <- field_mappings$mapped[i]
if (mapped_name != "drop" && !is.na(mapped_name) && mapped_name != "") {
if (!mapped_name %in% names(mapped_columns)) {
mapped_columns[[mapped_name]] <- c()
}
mapped_columns[[mapped_name]] <- c(mapped_columns[[mapped_name]], field_name)
}
}
# 创建新的数据框来保存结果
new_df <- data.frame(row.names = 1:nrow(result_df))
# 处理每个映射后的列名
for (mapped_name in names(mapped_columns)) {
source_columns <- mapped_columns[[mapped_name]]
# 如果只有一个源列，直接复制
if (length(source_columns) == 1) {
if (source_columns %in% colnames(result_df)) {
new_df[[mapped_name]] <- result_df[[source_columns]]
}
} else {
# 如果有多个源列，合并它们（优先使用非NA值）
combined_column <- rep(NA, nrow(result_df))
for (col in source_columns) {
if (col %in% colnames(result_df)) {
# 对于每一行，如果当前值是NA且源列值不是NA，则使用源列值
for (r in 1:nrow(result_df)) {
if (is.na(combined_column[r]) && !is.na(result_df[r, col])) {
combined_column[r] <- result_df[r, col]
}
}
}
}
new_df[[mapped_name]] <- combined_column
}
}
# 将新数据框赋值给result_df
result_df <- new_df
return(result_df)
}
# 使用示例
df1 <- process_special_csv("temp/MonthlyTransaction_ALL.CSV")
library(stringr)
library(readr)
library(stringi)
## 读取CSV文件
process_special_csv <- function(file_path) {
# 1. 检查文件是否存在
if (!file.exists(file_path)) {
stop(paste("文件未找到:", file_path))
}
# 2. 检查文件编码
encoding <- guess_encoding(file_path)$encoding[1]
# 检查编码是否有效
if (is.na(encoding)) {
stop("无法确定文件编码，请检查文件格式")
}
message(paste("检测到文件编码为:", encoding))
# 3.检查编码是否支持转换
if (!encoding %in% iconvlist()) {
stop(paste("不支持的编码格式:", encoding))
}
# 4.读取文件二进制内容
tryCatch({
binary_content <- readBin(file_path, "raw", file.info(file_path)$size)
message("成功读取文件二进制内容")
print(paste("读取到", length(binary_content), "字节数据"))
}, error = function(e) {
stop(paste("读取文件二进制内容时出错:", e$message))
})
# 5. 使用iconv将二进制内容转换为UTF-8编码文本内容
raw_text <- iconv(list(binary_content), from = encoding, to = "UTF-8")
# 6. 合并为单个字符串
full_text <- paste(raw_text, collapse = " ")
# 7. 使用正则表达式提取每条记录，每条记录以"CITIBANK"开始
records <- unlist(strsplit(full_text, '"CITIBANK'))
# 8. 移除第一个元素（如果它是空的）
if (records[1] == "") {
records <- records[-1]
}
# 9. 为每条记录重新添加"CITIBANK"前缀
records <- paste0('"CITIBANK', records)
# 10. 预分配结果列表
parsed_records <- list()
# 11. 遍历每条记录
for (i in seq_along(records)) {
# 提取双引号之间的内容
fields <- gregexpr('"[^"]*"', records[i])
field_contents <- regmatches(records[i], fields)[[1]]
# 移除双引号
field_contents <- gsub('"', '', field_contents)
# 添加到结果列表
parsed_records[[i]] <- field_contents
}
# 12. 确定最大字段数
max_fields <- max(sapply(parsed_records, length))
# 13. 创建数据框
result_df <- data.frame(matrix(NA, nrow = length(parsed_records), ncol = max_fields))
# 14. 填充数据框
for (i in seq_along(parsed_records)) {
result_df[i, 1:length(parsed_records[[i]])] <- parsed_records[[i]]
}
# 15. 设置列名
colnames(result_df) <- paste0("Field", 1:max_fields)
# 16. 读取字段映射文件并应用列名
field_mappings <- read.table("app/r_scripts/r_processor/fields_mapping.txt", sep = "=",
stringsAsFactors = FALSE, strip.white = TRUE,
col.names = c("original", "mapped"))
# 创建一个映射表，记录每个目标列名对应的原始列名
mapped_columns <- list()
for (i in 1:nrow(field_mappings)) {
field_name <- field_mappings$original[i]
mapped_name <- field_mappings$mapped[i]
if (mapped_name != "drop" && !is.na(mapped_name) && mapped_name != "") {
if (!mapped_name %in% names(mapped_columns)) {
mapped_columns[[mapped_name]] <- c()
}
mapped_columns[[mapped_name]] <- c(mapped_columns[[mapped_name]], field_name)
}
}
# 创建新的数据框来保存结果
new_df <- data.frame(row.names = 1:nrow(result_df))
# 处理每个映射后的列名
for (mapped_name in names(mapped_columns)) {
source_columns <- mapped_columns[[mapped_name]]
# 如果只有一个源列，直接复制
if (length(source_columns) == 1) {
if (source_columns %in% colnames(result_df)) {
new_df[[mapped_name]] <- result_df[[source_columns]]
}
} else {
# 如果有多个源列，合并它们（优先使用非NA值）
combined_column <- rep(NA, nrow(result_df))
for (col in source_columns) {
if (col %in% colnames(result_df)) {
# 对于每一行，如果当前值是NA且源列值不是NA，则使用源列值
for (r in 1:nrow(result_df)) {
if (is.na(combined_column[r]) && !is.na(result_df[r, col])) {
combined_column[r] <- result_df[r, col]
}
}
}
}
new_df[[mapped_name]] <- combined_column
}
}
# 将新数据框赋值给result_df
result_df <- new_df
return(result_df)
}
# 使用示例
df1 <- process_special_csv("temp/MonthlyTransaction_ALL.CSV")
df2 <- process_special_csv("temp/MonthlyTransaction_ALL_04.CSV")
df <- rbind(df1, df2)
View(df2)
library(stringr)
library(readr)
library(stringi)
## 读取CSV文件
process_special_csv <- function(file_path) {
# 1. 检查文件是否存在
if (!file.exists(file_path)) {
stop(paste("文件未找到:", file_path))
}
# 2. 检查文件编码
encoding <- guess_encoding(file_path)$encoding[1]
# 检查编码是否有效
if (is.na(encoding)) {
stop("无法确定文件编码，请检查文件格式")
}
message(paste("检测到文件编码为:", encoding))
# 3.检查编码是否支持转换
if (!encoding %in% iconvlist()) {
stop(paste("不支持的编码格式:", encoding))
}
# 4.读取文件二进制内容
tryCatch({
binary_content <- readBin(file_path, "raw", file.info(file_path)$size)
message("成功读取文件二进制内容")
print(paste("读取到", length(binary_content), "字节数据"))
}, error = function(e) {
stop(paste("读取文件二进制内容时出错:", e$message))
})
# 5. 使用iconv将二进制内容转换为UTF-8编码文本内容
raw_text <- iconv(list(binary_content), from = encoding, to = "UTF-8")
# 6. 合并为单个字符串
full_text <- paste(raw_text, collapse = " ")
# 7. 使用正则表达式提取每条记录，每条记录以"CITIBANK"开始
records <- unlist(strsplit(full_text, '"CITIBANK'))
# 8. 移除第一个元素（如果它是空的）
if (records[1] == "") {
records <- records[-1]
}
# 9. 为每条记录重新添加"CITIBANK"前缀
records <- paste0('"CITIBANK', records)
# 10. 预分配结果列表
parsed_records <- list()
# 11. 遍历每条记录
for (i in seq_along(records)) {
# 提取双引号之间的内容
fields <- gregexpr('"[^"]*"', records[i])
field_contents <- regmatches(records[i], fields)[[1]]
# 移除双引号
field_contents <- gsub('"', '', field_contents)
# 添加到结果列表
parsed_records[[i]] <- field_contents
}
# 12. 确定最大字段数
max_fields <- max(sapply(parsed_records, length))
# 13. 创建数据框
result_df <- data.frame(matrix(NA, nrow = length(parsed_records), ncol = max_fields))
# 14. 填充数据框
for (i in seq_along(parsed_records)) {
result_df[i, 1:length(parsed_records[[i]])] <- parsed_records[[i]]
}
# 15. 设置列名
colnames(result_df) <- paste0("Field", 1:max_fields)
# 16. 读取字段映射文件并应用列名
field_mappings <- read.table("app/r_scripts/r_processor/fields_mapping.txt", sep = "=",
stringsAsFactors = FALSE, strip.white = TRUE,
col.names = c("original", "mapped"))
for (i in 1:nrow(field_mappings)) {
field_name <- field_mappings$original[i]
if (field_name %in% colnames(result_df)) {
mapped_name <- field_mappings$mapped[i]
if (mapped_name != "drop" && !is.na(mapped_name)) {
colnames(result_df)[colnames(result_df) == field_name] <- mapped_name
}
}
}
# 17. 删除标记为"drop"的列
drop_fields <- field_mappings$original[tolower(field_mappings$mapped) == "drop"]
if (length(drop_fields) > 0) {
result_df <- result_df[, !colnames(result_df) %in% drop_fields]
}
return(result_df)
}
# 使用示例
df1 <- process_special_csv("temp/MonthlyTransaction_ALL.CSV")
df2 <- process_special_csv("temp/MonthlyTransaction_ALL_04.CSV")
df <- rbind(df1, df2)
View(df)
library(stringr)
library(readr)
library(stringi)
## 读取CSV文件
process_special_csv <- function(file_path) {
# 1. 检查文件是否存在
if (!file.exists(file_path)) {
stop(paste("文件未找到:", file_path))
}
# 2. 检查文件编码
encoding <- guess_encoding(file_path)$encoding[1]
# 检查编码是否有效
if (is.na(encoding)) {
stop("无法确定文件编码，请检查文件格式")
}
message(paste("检测到文件编码为:", encoding))
# 3.检查编码是否支持转换
if (!encoding %in% iconvlist()) {
stop(paste("不支持的编码格式:", encoding))
}
# 4.读取文件二进制内容
tryCatch({
binary_content <- readBin(file_path, "raw", file.info(file_path)$size)
message("成功读取文件二进制内容")
print(paste("读取到", length(binary_content), "字节数据"))
}, error = function(e) {
stop(paste("读取文件二进制内容时出错:", e$message))
})
# 5. 使用iconv将二进制内容转换为UTF-8编码文本内容
raw_text <- iconv(list(binary_content), from = encoding, to = "UTF-8")
# 6. 合并为单个字符串
full_text <- paste(raw_text, collapse = " ")
# 7. 使用正则表达式提取每条记录，每条记录以"CITIBANK"开始
records <- unlist(strsplit(full_text, '"CITIBANK'))
# 8. 移除第一个元素（如果它是空的）
if (records[1] == "") {
records <- records[-1]
}
# 9. 为每条记录重新添加"CITIBANK"前缀
records <- paste0('"CITIBANK', records)
# 10. 预分配结果列表
parsed_records <- list()
# 11. 遍历每条记录
for (i in seq_along(records)) {
# 提取双引号之间的内容
fields <- gregexpr('"[^"]*"', records[i])
field_contents <- regmatches(records[i], fields)[[1]]
# 移除双引号
field_contents <- gsub('"', '', field_contents)
# 添加到结果列表
parsed_records[[i]] <- field_contents
}
# 12. 确定最大字段数
max_fields <- max(sapply(parsed_records, length))
# 13. 创建数据框
result_df <- data.frame(matrix(NA, nrow = length(parsed_records), ncol = max_fields))
# 14. 填充数据框
for (i in seq_along(parsed_records)) {
result_df[i, 1:length(parsed_records[[i]])] <- parsed_records[[i]]
}
# 15. 设置列名
colnames(result_df) <- paste0("Field", 1:max_fields)
# 16. 读取字段映射文件并应用列名
field_mappings <- read.table("app/r_scripts/r_processor/fields_mapping.txt", sep = "=",
stringsAsFactors = FALSE, strip.white = TRUE,
col.names = c("original", "mapped"))
# 创建一个新的数据框来存储合并后的结果
merged_df <- data.frame(row.names = 1:nrow(result_df))
# 找出所有唯一的映射目标列名
unique_mapped_names <- unique(field_mappings$mapped[!is.na(field_mappings$mapped) &
field_mappings$mapped != "drop" &
field_mappings$mapped != "Drop"])
# 对每个唯一的映射名称进行处理
for (target_name in unique_mapped_names) {
# 找出所有映射到此名称的原始列
source_cols <- field_mappings$original[field_mappings$mapped == target_name &
field_mappings$original %in% colnames(result_df)]
if (length(source_cols) == 0) {
next  # 如果没有找到匹配的列，跳过
} else if (length(source_cols) == 1) {
# 只有一个源列，直接复制
merged_df[[target_name]] <- result_df[[source_cols]]
} else {
# 有多个源列，需要合并它们的值
merged_col <- rep(NA, nrow(result_df))
for (row_idx in 1:nrow(result_df)) {
for (col_name in source_cols) {
val <- result_df[row_idx, col_name]
if (!is.na(val) && nchar(trimws(val)) > 0) {
# 如果找到非空值，使用它并停止寻找
merged_col[row_idx] <- val
break
}
}
}
merged_df[[target_name]] <- merged_col
}
}
# 将合并后的数据框替换原来的结果
result_df <- merged_df
}
# 使用示例
df1 <- process_special_csv("temp/MonthlyTransaction_ALL.CSV")
df2 <- process_special_csv("temp/MonthlyTransaction_ALL_04.CSV")
df <- rbind(df1, df2)
View(df)
library(stringr)
library(readr)
library(stringi)
## 读取CSV文件
process_special_csv <- function(file_path) {
# 1. 检查文件是否存在
if (!file.exists(file_path)) {
stop(paste("文件未找到:", file_path))
}
# 2. 检查文件编码
encoding <- guess_encoding(file_path)$encoding[1]
# 检查编码是否有效
if (is.na(encoding)) {
stop("无法确定文件编码，请检查文件格式")
}
message(paste("检测到文件编码为:", encoding))
# 3.检查编码是否支持转换
if (!encoding %in% iconvlist()) {
stop(paste("不支持的编码格式:", encoding))
}
# 4.读取文件二进制内容
tryCatch({
binary_content <- readBin(file_path, "raw", file.info(file_path)$size)
message("成功读取文件二进制内容")
print(paste("读取到", length(binary_content), "字节数据"))
}, error = function(e) {
stop(paste("读取文件二进制内容时出错:", e$message))
})
# 5. 使用iconv将二进制内容转换为UTF-8编码文本内容
raw_text <- iconv(list(binary_content), from = encoding, to = "UTF-8")
# 6. 合并为单个字符串
full_text <- paste(raw_text, collapse = " ")
# 7. 使用正则表达式提取每条记录，每条记录以"CITIBANK"开始
records <- unlist(strsplit(full_text, '"CITIBANK'))
# 8. 移除第一个元素（如果它是空的）
if (records[1] == "") {
records <- records[-1]
}
# 9. 为每条记录重新添加"CITIBANK"前缀
records <- paste0('"CITIBANK', records)
# 10. 预分配结果列表
parsed_records <- list()
# 11. 遍历每条记录
for (i in seq_along(records)) {
# 提取双引号之间的内容
fields <- gregexpr('"[^"]*"', records[i])
field_contents <- regmatches(records[i], fields)[[1]]
# 移除双引号
field_contents <- gsub('"', '', field_contents)
# 添加到结果列表
parsed_records[[i]] <- field_contents
}
# 12. 确定最大字段数
max_fields <- max(sapply(parsed_records, length))
# 13. 创建数据框
result_df <- data.frame(matrix(NA, nrow = length(parsed_records), ncol = max_fields))
# 14. 填充数据框
for (i in seq_along(parsed_records)) {
result_df[i, 1:length(parsed_records[[i]])] <- parsed_records[[i]]
}
# 15. 设置列名
colnames(result_df) <- paste0("Field", 1:max_fields)
# 16. 读取字段映射文件并应用列名
field_mappings <- read.table("app/r_scripts/r_processor/fields_mapping.txt", sep = "=",
stringsAsFactors = FALSE, strip.white = TRUE,
col.names = c("original", "mapped"))
# 创建一个新的数据框来存储合并后的结果
merged_df <- data.frame(row.names = 1:nrow(result_df))
# 找出所有唯一的映射目标列名
unique_mapped_names <- unique(field_mappings$mapped[!is.na(field_mappings$mapped) &
field_mappings$mapped != "drop" &
field_mappings$mapped != "Drop"])
# 对每个唯一的映射名称进行处理
for (target_name in unique_mapped_names) {
# 找出所有映射到此名称的原始列
source_cols <- field_mappings$original[field_mappings$mapped == target_name &
field_mappings$original %in% colnames(result_df)]
if (length(source_cols) == 0) {
next  # 如果没有找到匹配的列，跳过
} else if (length(source_cols) == 1) {
# 只有一个源列，直接复制
merged_df[[target_name]] <- result_df[[source_cols]]
} else {
# 有多个源列，需要合并它们的值
merged_col <- rep(NA, nrow(result_df))
for (row_idx in 1:nrow(result_df)) {
for (col_name in source_cols) {
val <- result_df[row_idx, col_name]
if (!is.na(val) && nchar(trimws(val)) > 0) {
# 如果找到非空值，使用它并停止寻找
merged_col[row_idx] <- val
break
}
}
}
merged_df[[target_name]] <- merged_col
}
}
# 将合并后的数据框替换原来的结果
result_df <- merged_df
return(result_df)
}
# 使用示例
df1 <- process_special_csv("temp/MonthlyTransaction_ALL.CSV")
df2 <- process_special_csv("temp/MonthlyTransaction_ALL_04.CSV")
df <- rbind(df1, df2)
View(df)
View(df1)
View(df1)
